# 双指针思路

双指针（快慢指针）：**通过一个快指针和慢指针在一个for循环下完成两个for循环的工作**
- 快指针：寻找新数组元素，新数组即不含目标元素的数组
- 慢指针：指向更新新数组下标的位置
# 移除元素
## 题目

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95 "https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95")** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

假设 `nums` 中不等于 `val` 的元素数量为 `k`，要通过此题，您需要执行以下操作：

- 更改 `nums` 数组，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。`nums` 的其余元素和 `nums` 的大小并不重要。
- 返回 `k`。
## 解题思路

其中快指针用于查找元素，因此快指针会遍历整个数组，其中慢指针用于指向新数组的下标，具体思路如下：
快指针遍历整个数组，快指针对应的元素 `nums[fast]` 有两种情况
	`nums[fast]` 等于 `val` ，则应该跳过该元素，`slow` 指针不移动
	`nums[fast]` 不等于 `val` ，则应该将该元素添加至更新的数组中，将 `nums[fast]` 中的元素赋值给 `nums[slow]` ，并将慢指针移动到下一个位置
# 有序数组的平方
## 题目

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。
## 解题思路

数组其实是有序的， 只不过负数平方之后可能成为最大数了。
那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。
此时可以考虑双指针法了，`i` 指向起始位置，`j` 指向终止位置。
定义一个新数组 `result` ，和 `nums` 数组一样的大小，让 `k` 指向 `result` 数组终止位置。
循环条件定义为 `i <= j` 这是因为比对最后两个数后只能处理一个数字，因此需要再处理一次最后一个数：
- 如果`nums[i] * nums[i] < nums[j] * nums[j]` 那么`result[k--] = nums[j] * nums[j];` 
- 如果`nums[i] * nums[i] >= nums[j] * nums[j]` 那么`result[k--] = nums[i] * nums[i];`
